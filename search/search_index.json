{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Saleor SDK Python is a Python library that implements tools and solutions useful in Saleor application development, including: the saleor_sdk.crypto package for working with Saleor's auth. Before starting, you should familiarize yourself with Saleor's Extending Saleor documentation and learn basic concepts like apps, webhooks and events. This SDK is framework agnostic. It can be used with any Python web framework, or without framework as part of a script. What about the Python App Framework? \u00b6 The saleor-app-framework-python has been deprecated and is no longer maintained. Installation \u00b6 pip install saleor-sdk-python Key features \u00b6 CLI tools automating common development tasks: testing, linting and publication. CLI utility for deserializing Saleor's GraphQL IDs values to reveal type names and their database IDs - helpful in debugging and local development. Crypto module helping with Saleor authentication, both JWT verification and webhook signature verification - provides a way to manage Saleor issued signatures Marina module - more on that in a later time... Best served with \u00b6 https://ariadnegraphql.org/ https://github.com/mirumee/ariadne-codegen","title":"Introduction"},{"location":"#introduction","text":"Saleor SDK Python is a Python library that implements tools and solutions useful in Saleor application development, including: the saleor_sdk.crypto package for working with Saleor's auth. Before starting, you should familiarize yourself with Saleor's Extending Saleor documentation and learn basic concepts like apps, webhooks and events. This SDK is framework agnostic. It can be used with any Python web framework, or without framework as part of a script.","title":"Introduction"},{"location":"#what-about-the-python-app-framework","text":"The saleor-app-framework-python has been deprecated and is no longer maintained.","title":"What about the Python App Framework?"},{"location":"#installation","text":"pip install saleor-sdk-python","title":"Installation"},{"location":"#key-features","text":"CLI tools automating common development tasks: testing, linting and publication. CLI utility for deserializing Saleor's GraphQL IDs values to reveal type names and their database IDs - helpful in debugging and local development. Crypto module helping with Saleor authentication, both JWT verification and webhook signature verification - provides a way to manage Saleor issued signatures Marina module - more on that in a later time...","title":"Key features"},{"location":"#best-served-with","text":"https://ariadnegraphql.org/ https://github.com/mirumee/ariadne-codegen","title":"Best served with"},{"location":"tools/","text":"External tools \u00b6 Ngrok \u00b6 A tunneling service like ngrok , might help you with your work and to install your app on a Saleor Cloud developer instance - it exposes a port on your local machine to the world on an Ngrok url, via that url a Cloud Saleor instance can reach the application on your local environment. sequenceDiagram participant SAL as Saleor participant NGR as Ngrok participant LOC as Local LOC ->> NGR: Request URL / Setup tunnel NGR ->> LOC: Tunnel setup SAL ->> NGR: Request your.ngrok.url NGR ->> LOC: Request your designated port LOC ->> NGR: Response NGR ->> SAL: Response","title":"External tools"},{"location":"tools/#external-tools","text":"","title":"External tools"},{"location":"tools/#ngrok","text":"A tunneling service like ngrok , might help you with your work and to install your app on a Saleor Cloud developer instance - it exposes a port on your local machine to the world on an Ngrok url, via that url a Cloud Saleor instance can reach the application on your local environment. sequenceDiagram participant SAL as Saleor participant NGR as Ngrok participant LOC as Local LOC ->> NGR: Request URL / Setup tunnel NGR ->> LOC: Tunnel setup SAL ->> NGR: Request your.ngrok.url NGR ->> LOC: Request your designated port LOC ->> NGR: Response NGR ->> SAL: Response","title":"Ngrok"},{"location":"examples/simple/","text":"Simple FastAPI Example \u00b6 The following is a single module FastAPI app written as a demo of the Saleor SDK Python package. This should not be treated as a production ready application. For the sake of time let's import everything that will be needed upfront, initialize the app and put a JWKS storage in place: from fastapi import FastAPI , Request , Depends , Header from pydantic_settings import BaseSettings import httpx from jwt.api_jwk import PyJWKSet from saleor_sdk.schemas.manifest import Manifest , Webhook from saleor_sdk.schemas.enums import Permission , WebhookAsyncEvents from saleor_sdk.crypto.utils import decode_webook_payload , decode_jwt from saleor_sdk.crypto.exceptions import JWKSKeyMissing class Settings ( BaseSettings ): debug : bool = False settings = Settings ( debug = True ) app = FastAPI ( debug = settings . debug ) saleor_jwks = None Declare the App manifest \u00b6 @app . get ( \"/api/manifest\" ) async def manifest ( request : Request ): return Manifest ( id = \"simple-sdk-test-app\" , version = \"0.0.0\" , name = \"Simple SDK Test APP\" , permissions = [ Permission . MANAGE_ORDERS , \"MANAGE_CHECKOUTS\" ], app_url = str ( request . url_for ( \"app_config\" )), token_target_url = str ( request . url_for ( \"register\" )), webhooks = [ Webhook ( name = \"Order Handler\" , async_events = [ WebhookAsyncEvents . ORDER_CREATED , \"ORDER_UPDATED\" ], query = \"subscription { event { issuedAt issuingPrincipal { ... on App { id } ... on User { id } } ... on OrderCreated { order { id }} ... on OrderUpdated { order { id }}}}\" , target_url = str ( request . url_for ( \"order_handler\" )), is_active = True , ) ], ) There are a few things to notice here: enums - the SDK will try to keep the definitions up-to-date with Saleor but there is no promise this will always meet your needs (time-wise), this is why you can use both, the definitions from saleor_sdk.schemas.enums and plain strings. request.url_for() - Saleor needs a full URL to your endpoint, here we leverage FastAPI's resolver (be mindful about what your proxy is doing, i.e. it's easy to hide crucial information from FastAPI with Gunicorn) Subscription queries - the payload that webhook is to carry. More on Subscription queries \u00b6 Since Saleor 3.2 (and 3.6 for synchronous events) one can define the payload that Saleor will send to an app - this allows you to define a payload that is meaningful to the app. Saleor docs: Subscription Webhook Payloads A formatted query from the example looks like this: subscription { event { issuedAt issuingPrincipal { ... on App { id } ... on User { id } } ... on OrderCreated { order { id } } ... on OrderUpdated { order { id } } } } and will result in the following payload being sent to the app: { \"issuedAt\" : \"2022-12-12T00:37:17.405467+00:00\" , \"issuingPrincipal\" : { \"id\" : \"VXNlcjoyMDU5ODA1MTg0\" }, \"order\" : { \"id\" : \"T3JkZXI6MWFkNzZjOTctZDkxNy00NjRmLWIwNzUtOTljNzcwY2IzOWI4\" } } Define some commonly used dependencies \u00b6 async def get_saleor_event ( saleor_event : str = Header ( ... , alias = \"Saleor-Event\" )): return saleor_event async def get_saleor_domain ( saleor_domain : str = Header ( ... , alias = \"Saleor-Domain\" )): return saleor_domain async def get_saleor_signature ( saleor_signature : str = Header ( ... , alias = \"Saleor-Signature\" ) ): return saleor_signature JWKS and user JWT verification \u00b6 There are currently two ways to verify the authenticity of a Saleor issued JWT: - online - by calling Saleor to check (deprecated by Saleor) - offline - by checking with Saleor's public keyset. This library only supports the offline method. Saleor instances expose a /.well-known/jwks.json endpoint which exposes the public part of the RSA key used to sign the JWTs. With that we can verify if the incoming token is indeed coming straight from Saleor and if we can trust it's claims. To do that we need a storage within the app's memory to hold on to the JWKS (JSON Web Key Set), in this example we are simply using a global variable. The get_saleor_user dependency ensures the JWKS was initialized (first request in the runtime), then validates the token. If the local JWKS is missing a key, a JWKSKeyMissing error will be raised and an attempt to get a fresh one from Saleor will be made - this might happen when Saleor rotates the keys and starts signing JWTs with the new key. async def fetch_jwks ( saleor_domain ): async with httpx . AsyncClient () as client : response = await client . get ( f \"https:// { saleor_domain } /.well-known/jwks.json\" ) return response . content async def get_saleor_user ( saleor_domain : str = Depends ( get_saleor_domain ), saleor_token : str = Header ( ... , alias = \"Saleor-Token\" ), ): global saleor_jwks if not saleor_jwks : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts = 1 while max_attempts : try : return decode_jwt ( jwt = saleor_token , jwks = saleor_jwks , ) except JWKSKeyMissing as exc : if max_attempts : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts -= 1 else : raise Here's how it roughly works in sequence sequenceDiagram actor USR as User participant SAL as Saleor participant APP as App participant STO as JWKS Storage USR ->> SAL: Here are my credentials, give me a JWT SAL ->> USR: Here's your JWT USR ->> APP: Give me that secret resource APP ->> STO: I've got a JWT with kid=1 do you have something on that? alt Storage does not have the kid=1 STO ->> APP: No I don't APP ->> SAL: Fetch JWKS SAL ->> APP: JWKS APP ->> STO: Save JWKS else STO ->> APP: Yes, here is the public key end APP ->> APP: Verify the JWT signature APP ->> USR: Here's the data Webhook signature verification \u00b6 A very similar process applies to webhook authenticity verification. Leveraging the public key pair issued by Saleor the signature of a JWS (a JWT with detached payload) that is sent with a webhook can be verified in an offline manner. async def verify_webhook_signature ( request : Request , saleor_domain : str = Depends ( get_saleor_domain ), jws : str = Depends ( get_saleor_signature ), ): global saleor_jwks if not saleor_jwks : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts = 1 while max_attempts : try : return decode_webook_payload ( jws = jws , jwks = saleor_jwks , webhook_payload = await request . body (), ) except JWKSKeyMissing as exc : if max_attempts : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts -= 1 else : raise Finally define the app endpoints \u00b6 You need the two endpoints required by Saleor's framework: @app . get ( \"/\" , name = \"app_config\" ) async def app_config (): return \"OK\" @app . post ( \"/api/register\" , name = \"register\" ) async def register (): return \"OK\" app_config - this is the endpoint that is expected to respond with HTML that will initialize a React App in the Saleor Dashboard (read more on @saleor/app-sdk ) register - this endpoint receives the app_token which needs to be persisted securely, it's used by the app to authenticate with Saleor Further we define the order webhook handler which leverages our verify_webhook_signature dependency. @app . post ( \"/api/webhook/order\" , name = \"order_handler\" ) async def order_handler ( request : Request , _verify_webhook_signature = Depends ( verify_webhook_signature ), event_type = Depends ( get_saleor_event ), ): print ( event_type ) # Use in case you have one handler for many event types print ( await request . body ()) return \"OK\" And an additional endpoint that could be used by the Dashboard UI to for example change the app configuration async def user_login ( saleor_user = Depends ( get_saleor_user )): print ( saleor_user ) return \"OK\" Running the complete example \u00b6 Install the examples dependencies with: hatch -e examples shell Then navigate to the example and run it with uvicorn: cd docs/examples/simple uvicorn app:app --reload","title":"Simple FastAPI Example"},{"location":"examples/simple/#simple-fastapi-example","text":"The following is a single module FastAPI app written as a demo of the Saleor SDK Python package. This should not be treated as a production ready application. For the sake of time let's import everything that will be needed upfront, initialize the app and put a JWKS storage in place: from fastapi import FastAPI , Request , Depends , Header from pydantic_settings import BaseSettings import httpx from jwt.api_jwk import PyJWKSet from saleor_sdk.schemas.manifest import Manifest , Webhook from saleor_sdk.schemas.enums import Permission , WebhookAsyncEvents from saleor_sdk.crypto.utils import decode_webook_payload , decode_jwt from saleor_sdk.crypto.exceptions import JWKSKeyMissing class Settings ( BaseSettings ): debug : bool = False settings = Settings ( debug = True ) app = FastAPI ( debug = settings . debug ) saleor_jwks = None","title":"Simple FastAPI Example"},{"location":"examples/simple/#declare-the-app-manifest","text":"@app . get ( \"/api/manifest\" ) async def manifest ( request : Request ): return Manifest ( id = \"simple-sdk-test-app\" , version = \"0.0.0\" , name = \"Simple SDK Test APP\" , permissions = [ Permission . MANAGE_ORDERS , \"MANAGE_CHECKOUTS\" ], app_url = str ( request . url_for ( \"app_config\" )), token_target_url = str ( request . url_for ( \"register\" )), webhooks = [ Webhook ( name = \"Order Handler\" , async_events = [ WebhookAsyncEvents . ORDER_CREATED , \"ORDER_UPDATED\" ], query = \"subscription { event { issuedAt issuingPrincipal { ... on App { id } ... on User { id } } ... on OrderCreated { order { id }} ... on OrderUpdated { order { id }}}}\" , target_url = str ( request . url_for ( \"order_handler\" )), is_active = True , ) ], ) There are a few things to notice here: enums - the SDK will try to keep the definitions up-to-date with Saleor but there is no promise this will always meet your needs (time-wise), this is why you can use both, the definitions from saleor_sdk.schemas.enums and plain strings. request.url_for() - Saleor needs a full URL to your endpoint, here we leverage FastAPI's resolver (be mindful about what your proxy is doing, i.e. it's easy to hide crucial information from FastAPI with Gunicorn) Subscription queries - the payload that webhook is to carry.","title":"Declare the App manifest"},{"location":"examples/simple/#more-on-subscription-queries","text":"Since Saleor 3.2 (and 3.6 for synchronous events) one can define the payload that Saleor will send to an app - this allows you to define a payload that is meaningful to the app. Saleor docs: Subscription Webhook Payloads A formatted query from the example looks like this: subscription { event { issuedAt issuingPrincipal { ... on App { id } ... on User { id } } ... on OrderCreated { order { id } } ... on OrderUpdated { order { id } } } } and will result in the following payload being sent to the app: { \"issuedAt\" : \"2022-12-12T00:37:17.405467+00:00\" , \"issuingPrincipal\" : { \"id\" : \"VXNlcjoyMDU5ODA1MTg0\" }, \"order\" : { \"id\" : \"T3JkZXI6MWFkNzZjOTctZDkxNy00NjRmLWIwNzUtOTljNzcwY2IzOWI4\" } }","title":"More on Subscription queries"},{"location":"examples/simple/#define-some-commonly-used-dependencies","text":"async def get_saleor_event ( saleor_event : str = Header ( ... , alias = \"Saleor-Event\" )): return saleor_event async def get_saleor_domain ( saleor_domain : str = Header ( ... , alias = \"Saleor-Domain\" )): return saleor_domain async def get_saleor_signature ( saleor_signature : str = Header ( ... , alias = \"Saleor-Signature\" ) ): return saleor_signature","title":"Define some commonly used dependencies"},{"location":"examples/simple/#jwks-and-user-jwt-verification","text":"There are currently two ways to verify the authenticity of a Saleor issued JWT: - online - by calling Saleor to check (deprecated by Saleor) - offline - by checking with Saleor's public keyset. This library only supports the offline method. Saleor instances expose a /.well-known/jwks.json endpoint which exposes the public part of the RSA key used to sign the JWTs. With that we can verify if the incoming token is indeed coming straight from Saleor and if we can trust it's claims. To do that we need a storage within the app's memory to hold on to the JWKS (JSON Web Key Set), in this example we are simply using a global variable. The get_saleor_user dependency ensures the JWKS was initialized (first request in the runtime), then validates the token. If the local JWKS is missing a key, a JWKSKeyMissing error will be raised and an attempt to get a fresh one from Saleor will be made - this might happen when Saleor rotates the keys and starts signing JWTs with the new key. async def fetch_jwks ( saleor_domain ): async with httpx . AsyncClient () as client : response = await client . get ( f \"https:// { saleor_domain } /.well-known/jwks.json\" ) return response . content async def get_saleor_user ( saleor_domain : str = Depends ( get_saleor_domain ), saleor_token : str = Header ( ... , alias = \"Saleor-Token\" ), ): global saleor_jwks if not saleor_jwks : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts = 1 while max_attempts : try : return decode_jwt ( jwt = saleor_token , jwks = saleor_jwks , ) except JWKSKeyMissing as exc : if max_attempts : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts -= 1 else : raise Here's how it roughly works in sequence sequenceDiagram actor USR as User participant SAL as Saleor participant APP as App participant STO as JWKS Storage USR ->> SAL: Here are my credentials, give me a JWT SAL ->> USR: Here's your JWT USR ->> APP: Give me that secret resource APP ->> STO: I've got a JWT with kid=1 do you have something on that? alt Storage does not have the kid=1 STO ->> APP: No I don't APP ->> SAL: Fetch JWKS SAL ->> APP: JWKS APP ->> STO: Save JWKS else STO ->> APP: Yes, here is the public key end APP ->> APP: Verify the JWT signature APP ->> USR: Here's the data","title":"JWKS and user JWT verification"},{"location":"examples/simple/#webhook-signature-verification","text":"A very similar process applies to webhook authenticity verification. Leveraging the public key pair issued by Saleor the signature of a JWS (a JWT with detached payload) that is sent with a webhook can be verified in an offline manner. async def verify_webhook_signature ( request : Request , saleor_domain : str = Depends ( get_saleor_domain ), jws : str = Depends ( get_saleor_signature ), ): global saleor_jwks if not saleor_jwks : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts = 1 while max_attempts : try : return decode_webook_payload ( jws = jws , jwks = saleor_jwks , webhook_payload = await request . body (), ) except JWKSKeyMissing as exc : if max_attempts : saleor_jwks = PyJWKSet . from_json ( await fetch_jwks ( saleor_domain )) max_attempts -= 1 else : raise","title":"Webhook signature verification"},{"location":"examples/simple/#finally-define-the-app-endpoints","text":"You need the two endpoints required by Saleor's framework: @app . get ( \"/\" , name = \"app_config\" ) async def app_config (): return \"OK\" @app . post ( \"/api/register\" , name = \"register\" ) async def register (): return \"OK\" app_config - this is the endpoint that is expected to respond with HTML that will initialize a React App in the Saleor Dashboard (read more on @saleor/app-sdk ) register - this endpoint receives the app_token which needs to be persisted securely, it's used by the app to authenticate with Saleor Further we define the order webhook handler which leverages our verify_webhook_signature dependency. @app . post ( \"/api/webhook/order\" , name = \"order_handler\" ) async def order_handler ( request : Request , _verify_webhook_signature = Depends ( verify_webhook_signature ), event_type = Depends ( get_saleor_event ), ): print ( event_type ) # Use in case you have one handler for many event types print ( await request . body ()) return \"OK\" And an additional endpoint that could be used by the Dashboard UI to for example change the app configuration async def user_login ( saleor_user = Depends ( get_saleor_user )): print ( saleor_user ) return \"OK\"","title":"Finally define the app endpoints"},{"location":"examples/simple/#running-the-complete-example","text":"Install the examples dependencies with: hatch -e examples shell Then navigate to the example and run it with uvicorn: cd docs/examples/simple uvicorn app:app --reload","title":"Running the complete example"}]}